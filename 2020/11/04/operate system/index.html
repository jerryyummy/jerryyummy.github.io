<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/logo_miccall.png"/>
	<link rel="shortcut icon" href="/img/logo_miccall.png">
	
			    <title>
    Jerry's blog
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="jerry elementary life discovery" />
    
    	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	 
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/bg.jpg') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<meta name="generator" content="Hexo 5.2.0"></head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_coy.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">Jerry</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/Algorithm/">Algorithm</a></li><li><a class="category-link" href="/categories/Software-Engineer/">Software Engineer</a>
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="Introduction">
		                Introduction
		            </a>
		        </li>
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="标签">
		                标签
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
                    <li>
                        <a title="github" href="https://github.com/jerryyummy" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(https://s1.ax1x.com/2020/10/14/0I79hR.jpg);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >操作系统学习笔记（随时更新）</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <p>[toc]</p>
<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><ol>
<li><h2 id="计算机基本构成："><a href="#计算机基本构成：" class="headerlink" title="计算机基本构成："></a>计算机基本构成：</h2><p>处理器：当只有一个处理器，特指CPU</p>
<p>内存：存储数据和程序，易失性存储器</p>
<p>输入输出模块：在计算机和外部环境之间移动数据</p>
<p>系统总线：在上述三者提供通讯的设施</p>
</li>
<li><h2 id="中断："><a href="#中断：" class="headerlink" title="中断："></a>中断：</h2><p>程序中断，时钟中断，IO中断，硬件失效中断</p>
<p><em>中断可在主程序任何位置发生而非仅在一条特定指令处发生</em></p>
<p>多个中断的处理：禁止再次中断；定义中断优先级</p>
</li>
<li><h2 id="存储器的层次结构："><a href="#存储器的层次结构：" class="headerlink" title="存储器的层次结构："></a>存储器的层次结构：</h2><p>寄存器&gt;cache&gt;内存&gt;硬盘&gt;磁带</p>
</li>
<li><h2 id="执行IO操作技术："><a href="#执行IO操作技术：" class="headerlink" title="执行IO操作技术："></a>执行IO操作技术：</h2><p>可编程I/O操作；中断驱动I/O；DMA</p>
</li>
</ol>
<h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><ol>
<li><h2 id="操作系统的定义："><a href="#操作系统的定义：" class="headerlink" title="操作系统的定义："></a>操作系统的定义：</h2><p>控制应用程序执行的程序，应用和硬件之间充当接口的程序；负责管理资源，跟计算机软件一样执行的程序（最大的软件程序）</p>
</li>
<li><h2 id="操作系统的优点："><a href="#操作系统的优点：" class="headerlink" title="操作系统的优点："></a>操作系统的优点：</h2><p>方便（user/computer interface),有效（resource manager),可拓展（system software)</p>
</li>
<li><h2 id="evolution-of-os"><a href="#evolution-of-os" class="headerlink" title="evolution of os:"></a>evolution of os:</h2></li>
</ol>
<blockquote>
<p>serial processing（没有操作系统，程序员直接跟硬件打交道）;</p>
</blockquote>
<blockquote>
<p>simple batch systems（用户不用直接跟硬件打交道，有一个monitor）;在内存一次只执行一个工作，处理器必须等待I/O指令</p>
</blockquote>
<blockquote>
<p>multiprogrammed batch systems; 多个程序驻扎在内存，当前一个任务尚未执行完，但在等待IO时，下一个任务可以先使用CPU，相当于程序1虽然整体任务没有完成，但等待IO使得它主动让出CPU给程序2，和简单批处理不同，简单批处理需要前一个任务执行完毕。等IO中断返回，则第一个任务继续执行。</p>
<p>问题：如何管理多个程序的切换</p>
<p>When one job needs to wait for I/O, the processor can switch to the other job</p>
</blockquote>
<blockquote>
<p>time-sharing system;和多道程序不同，即便第一个程序正在使用CPU，而非等待IO，后续程序也可以以时间片来轮换使用CPU，相当于程序1被动出让CPU</p>
</blockquote>
<blockquote>
<p>-&gt; 易用性GUI -&gt; 分布式系统 -&gt; 服务云计算，大数据</p>
</blockquote>
<ol start="4">
<li><h2 id="进程：（被认为是一个数据结构）"><a href="#进程：（被认为是一个数据结构）" class="headerlink" title="进程：（被认为是一个数据结构）"></a>进程：（被认为是一个数据结构）</h2><p>–An executable program /code</p>
<p>–Associated data needed by the program</p>
<p>–Execution context of the program (the core)</p>
<p>•All information the operating system needs to manage the process</p>
</li>
<li><h2 id="内存管理："><a href="#内存管理：" class="headerlink" title="内存管理："></a>内存管理：</h2><p>•OS has five storage management responsibilities:</p>
<p>–Process isolation(进程隔离)</p>
<p>–Automatic allocation and management(自动分配和管理)</p>
<p>–Support of modular programming(模块化程序设计)</p>
<p>–Protection and access control (保护与存取控制)</p>
<p>–Long-term storage(长期存储)</p>
</li>
</ol>
<h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><ol>
<li><h2 id="进程的组成："><a href="#进程的组成：" class="headerlink" title="进程的组成："></a>进程的组成：</h2></li>
</ol>
<p>程序代码，与代码相关联的数据集，进程控制块</p>
<ol start="2">
<li><h2 id="进程的创建：新的批处理作业，交互登录，为提供服务而由操作系统创建，由现有进程派生"><a href="#进程的创建：新的批处理作业，交互登录，为提供服务而由操作系统创建，由现有进程派生" class="headerlink" title="进程的创建：新的批处理作业，交互登录，为提供服务而由操作系统创建，由现有进程派生"></a>进程的创建：新的批处理作业，交互登录，为提供服务而由操作系统创建，由现有进程派生</h2></li>
<li><h2 id="进程的终止："><a href="#进程的终止：" class="headerlink" title="进程的终止："></a>进程的终止：</h2><p>•Errors</p>
<p>–Data/protection/mem failure/illegal behavior</p>
<p>•By Parents process</p>
<p>•Normal completion</p>
</li>
<li><h2 id="进程状态："><a href="#进程状态：" class="headerlink" title="进程状态："></a>进程状态：</h2><p><img src="https://s1.ax1x.com/2020/10/21/B9YQGq.png" alt="B9YQGq.png"></p>
</li>
<li><h2 id="suspended-process："><a href="#suspended-process：" class="headerlink" title="suspended process："></a>suspended process：</h2><ul>
<li><p>程运行的比I/O快，进程需要等待I/O</p>
</li>
<li><p>Swap these processes to disk to free up more memory把进程交换到磁盘换取更多内存空间</p>
</li>
<li><p>•Blocked state becomes suspend state when swapped to disk</p>
<p><img src="https://s1.ax1x.com/2020/10/21/B9YGsU.png" alt="B9YGsU.png"></p>
</li>
</ul>
<ol start="6">
<li><h2 id="os-control-structures"><a href="#os-control-structures" class="headerlink" title="os control structures"></a>os control structures</h2><p>•Information about the current status of each process and resource (每个进程和资源的当前状态)</p>
<p>•Tables are constructed for manage 4 kinds of resources (操作系统构造并维护他所管理的四类资源实体的信息表)</p>
<p><img src="https://s1.ax1x.com/2020/10/21/B9YJLF.png" alt="B9YJLF.png"></p>
<blockquote>
<p>memory tables</p>
<blockquote>
<p>–Allocation of main memory to processes (分配给进程的主存)</p>
<p>–Allocation of secondary memory to processes (分配给进程的辅存)</p>
<p>–Protection attributes for access to shared memory regions(共享内存区域的保护属性)</p>
<p>–Information needed to manage virtual memory(虚拟内存的管理信息)</p>
</blockquote>
<p>I/O tables</p>
<blockquote>
<p>–I/O device is available or assigned(分配状态)</p>
<p>–Status of I/O operation </p>
<p>–Location in main memory being used as the source or destination of the I/O transfer (数据传送的源和目的地址)</p>
</blockquote>
<p>file tables(比如读写问题，需要知道文件当前的状态)</p>
<blockquote>
<p>–Existence of files</p>
<p>–Location on secondary memory</p>
<p>–Current Status</p>
<p>–Attributes</p>
</blockquote>
</blockquote>
</li>
<li><h2 id="process-control-structures"><a href="#process-control-structures" class="headerlink" title="process control structures"></a>process control structures</h2><blockquote>
<p>process image</p>
<blockquote>
<p>用户数据：用户空间中的可修改部分</p>
<p>用户程序：待执行的程序</p>
<p>栈：栈用于保存参数，过程调用地址和系统调用地址</p>
<p>进程控制块：进程标识符（唯一），处理器状态信息，进程控制信息</p>
</blockquote>
</blockquote>
</li>
<li><h2 id="process-control"><a href="#process-control" class="headerlink" title="process control"></a>process control</h2><blockquote>
<p>执行模式：用户模式，内核模式</p>
</blockquote>
<blockquote>
<p>进程创建过程：分配进程标识符-&gt;allocate space for this process-&gt;initialize process control block-&gt;set up appropriate linkages-&gt;扩充其他数据结构</p>
</blockquote>
<blockquote>
<p>进程切换</p>
<ol>
<li>Interrupt:•Clock interrupt •I/O interrupt •Memory fault</li>
<li>trap</li>
<li>supervisor call</li>
</ol>
</blockquote>
<blockquote>
<p>进程状态的变化：保存处理器上下文-&gt;更新处于运行态进程的pcb，修改进程状态-&gt;把pcb移到相应队列-&gt;选择另一个进程执行-&gt;更新所选进程的pcb，把状态改为运行态-&gt;更新内存管理数据结构-&gt;5.Restore context of the selected process</p>
</blockquote>
</li>
<li><h2 id="操作系统的执行："><a href="#操作系统的执行：" class="headerlink" title="操作系统的执行："></a>操作系统的执行：</h2><ol>
<li><p>无进程内核</p>
<p>–Execute kernel outside of any process</p>
<p>–Operating system code is executed as a separate entity that operates in privileged mode</p>
<p><img src="https://s1.ax1x.com/2020/10/21/B9YNdJ.png" alt="B9YNdJ.png"></p>
</li>
<li><p>在用户程序中运行</p>
<p>–Operating system software within context of a user process</p>
<p>–Process executes in privileged mode when executing operating system code</p>
<p><img src="https://s1.ax1x.com/2020/10/21/B9YUo9.png" alt="B9YUo9.png"></p>
</li>
<li><p>基于进程的os</p>
<p>–Implement operating system as a collection of system processes</p>
<p>–Useful in multi-processor or multi-computer environment</p>
<p><img src="https://s1.ax1x.com/2020/10/21/B9YdiR.png" alt="B9YdiR.png"></p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1><ol>
<li>进程与线程</li>
</ol>
<p>•Dispatching is referred to as a thread or lightweight process(调度的单位称为线程或轻量进程)</p>
<p>•Resource of ownership is referred to as a process or task(资源所有权的单位称为进程或者任务)</p>
<ol start="2">
<li>•Each thread has:</li>
</ol>
<p>–An execution state (running, ready, etc.)</p>
<p>–Saved thread context when not running</p>
<p>–Has an execution stack</p>
<p>–Some per-thread static storage for local variables（局部变量）</p>
<p>–Access to the memory and resources of its process （全局变量）</p>
<p>进程中的所有线程共享该进程的状态和资源</p>
<p><img src="https://s1.ax1x.com/2020/10/21/B9Y0Rx.png" alt="B9Y0Rx.png"></p>
<ol start="3">
<li>线程的优点：</li>
</ol>
<ul>
<li>创建线程时间短</li>
<li>终止进程花费时间少</li>
<li>同一进程间线程切换时间小于进程切换时间</li>
<li>线程提高了不同执行程序之间通信的效率</li>
</ul>
<ol start="4">
<li><p>线程状态：运行，就绪，阻塞</p>
<ul>
<li>线程状态改变相关操作</li>
</ul>
<p>–Spawn(派生)</p>
<p>•Spawn another thread</p>
<p>–Block(阻塞)</p>
<p>–Unblock(解除阻塞)</p>
<p>–Finish</p>
<p>•Deallocate register context and stacks</p>
</li>
<li><p>线程的分类</p>
<blockquote>
<p>User-leveI introduction:</p>
<blockquote>
<p>Multithread implemented by a threads library</p>
<p>•All thread management is done by the application</p>
<p>•The kernel is not aware of the existence of threads &amp; scheduling is done on a process basis</p>
<p><img src="https://s1.ax1x.com/2020/10/21/B9YBz6.png" alt="B9YBz6.png"></p>
</blockquote>
</blockquote>
<blockquote>
<p>Kernel-Level Thread</p>
<blockquote>
<p>•Kernel maintains context information for the process and the threads</p>
<p>•Scheduling is done on a thread basis</p>
<p><img src="https://s1.ax1x.com/2020/10/21/B9Ycee.png" alt="B9Ycee.png"></p>
</blockquote>
</blockquote>
<blockquote>
<p>Combined Approaches</p>
<blockquote>
<p>•Thread creation done in the user space</p>
<p>•Bulk of scheduling and synchronization of threads within application</p>
<p>•The multiple ULTs from a single application are mapped onto some (smaller or equal) number of KLTs</p>
<p>•One threads blocked cannot make the process blocked</p>
<p><img src="https://s1.ax1x.com/2020/10/21/B9YgdH.png" alt="B9YgdH.png"></p>
</blockquote>
</blockquote>
<blockquote>
<p>Other Arrangements</p>
<blockquote>
<p><img src="https://s1.ax1x.com/2020/10/21/B9Y2od.png" alt="B9Y2od.png"></p>
</blockquote>
</blockquote>
</li>
<li><p>Advantages of ULT to KLT</p>
<p>•Less overhead of thread switches(mode switches do not required) 节省两次状态转换的开销</p>
<p>•Scheduling can be application specific可以为应用程序量身定做调度算法</p>
<p>•ULTs can run on any operating system</p>
</li>
<li><p>Disadvantages of ULT to KLT</p>
<p>•One thread is blocked, all other threads of the process are blocked</p>
<p>•A multithreaded application cannot take advantage of multiprocessing（线程不能分配到多核）</p>
<p>•Ways to work around these drawbacks:</p>
<p>–Multiple processes（用多进程代替多线程）</p>
<p>–Jacketing套管：把一个产生阻塞的系统调用转换成一个非阻塞的系统调用</p>
</li>
<li><p>Advantages of KLT to ULT</p>
<p>–Multiple threads in one process can simultaneously run on multiple processors（多CPU执行）</p>
<p>–One threads blocked cannot make the other threads within the same process blocked（仅阻塞单个线程）</p>
<p>–Kernel routines themselves can be multithreaded</p>
</li>
<li><p>Disadvantages of KLT to ULT</p>
<p>•The principal disadvantage is that thread switch requires mode switches(模式切换) to the kernel</p>
</li>
</ol>
<h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><p>1.并发原理</p>
<ul>
<li><p>竞争条件发生在当多个进程或者线程在读写数据时，其最终结果依赖于多个进程或线程的指令执行顺序</p>
</li>
<li><p><img src="https://s1.ax1x.com/2020/10/21/B9YhWt.png" alt="B9YhWt.png"></p>
</li>
<li><p>进程的交互</p>
</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/10/21/B9Yoy8.png" alt="B9Yoy8.png"></p>
<ul>
<li><p>•Difficulties of Concurrency</p>
<p>–Sharing of global resources</p>
<p>–Operating system managing the allocation of resources optimally</p>
<p>–Difficult to locate programming errors</p>
</li>
<li><p>互斥的要求</p>
<p>1.一次只允许一个进程进入临界区，忙则等待</p>
<p>2.阻塞于临界区之外的进程不能干涉其他进程</p>
<p>3.不会发生饥饿和死锁</p>
<p>4.没有进程在临界区时，任何需要进入临界区的进程必须能够立即进入</p>
<p>5.对相关进程的执行速度和处理器数目没有要求</p>
<p>6.有限占用临界区</p>
</li>
</ul>
<p>2.硬件支持互斥</p>
<ol>
<li><p>中断禁用</p>
<p><img src="https://s1.ax1x.com/2020/10/21/B9YHeg.png" alt="B9YHeg.png"></p>
<p>执行效率明显降低，不适用于多处理器体系结构</p>
</li>
<li><p>专用机器指令</p>
<ul>
<li><p>Advantages</p>
<p>–By sharing main memory，it is applicable to any number of processes </p>
<p>–It is simple and therefore easy to verify</p>
<p>–It can be used to support multiple critical sections 支持多个临界区，每个临界区都可以用他自己的变量定义</p>
</li>
<li><p>•Disadvantages</p>
<p>–Busy-waiting(忙等待) consumes processor time</p>
<p>–Starvation(饥饿) is possible when a process leaves a critical section and more than one process is waiting. </p>
<p>–Deadlock (死锁) is possible</p>
<p>•If a low priority process has the critical region and a higher priority process needs, the higher priority process will obtain the processor to wait for the critical region</p>
</li>
</ul>
</li>
</ol>
<p>3.软件支持互斥</p>
<ol>
<li><p>Dekker</p>
<p><img src="https://s1.ax1x.com/2020/10/21/B9Yqoj.png" alt="B9Yqoj.png"></p>
</li>
<li><p>Peterson</p>
<p><img src="https://s1.ax1x.com/2020/10/21/B9YOFs.png" alt="B9YOFs.png"></p>
</li>
</ol>
<ol start="4">
<li><p>信号量（<strong>Semaphores</strong>）</p>
<ul>
<li><p>基本原理：两个或者多个进程可以通过简单的信号进行合作，一个进程可以被迫在一个位置停止，直到它收到一个信号</p>
</li>
<li><p>•For signaling, special variables called <strong>semaphores</strong> are used(一种称为<em>信号量</em>的特殊变量用来传递信号)，•If a process is <strong>waiting</strong> for a signal, it is <strong>blocked</strong> until that signal is <strong>sent</strong> (如果一个进程在等待一个信号，它会被阻塞，直到它等待的信号被发出）</p>
</li>
<li><p>•Semaphore : <strong>sem**</strong>变量** <strong>+ 2 atomic operations**</strong>原子操作**</p>
<blockquote>
<p>–<strong>Sem</strong>(integer value整数值) </p>
<p>①**semWait (P)**：</p>
<blockquote>
<p>①–sem</p>
</blockquote>
<blockquote>
<p>②If sem &lt; 0, the process executing the semWait is blocked.如果sem &lt; 0，则执行semWait的进程被阻塞</p>
</blockquote>
<blockquote>
<p>③else , process continue execute </p>
</blockquote>
<p>①**semSignal (V)**：</p>
<blockquote>
<p>①++sem</p>
</blockquote>
<blockquote>
<p>②If sem&gt;=0, then a process blocked by a semWait operation, if any, is unblocked.如果sem&gt;=0，那么被semWait操作阻塞的进程(如果有的话)被解除阻塞</p>
</blockquote>
</blockquote>
</li>
<li><p>信号量操作的实现（操作是原子操作）：</p>
<ol>
<li>在硬件或固件中实现</li>
<li>用软件实现，如Dekker或Peterson</li>
<li>在单处理器系统中通过禁止中断来实现</li>
</ol>
</li>
<li><p>信号量的应用：</p>
<ol>
<li><p>Mutual Exclusion互斥</p>
<blockquote>
<p><img src="https://s1.ax1x.com/2020/10/21/B9YXYn.png" alt="B9YXYn.png"></p>
<p><strong>当用于两个线程互斥，信号量初始值为</strong>1</p>
<p><strong>二元信号量与互斥锁的区别</strong></p>
<blockquote>
<p>互斥锁的上锁和解锁只能在同一个线程和进程调用；信号量的semWait和semSignal操作可以在不同的进程中调用</p>
</blockquote>
</blockquote>
<p>–One sem releases one information 一个信号量释放一个类型的信息</p>
<p>–Semaphore initialized to n: sem = n(已经有n个线程在等待进入临界区)</p>
<p>​    •n is the number of processes permit to enter; in another words: n processes is allowerd in its     critical section at a time(多个进程同时在临界区内)</p>
<p>​    •n=0, 同步问题(生产者/消费者问题)</p>
<p>​    •n=1，互斥问题(-m表示m个线程在等待)</p>
<p>​        &gt; 二元信号量，2个线程互斥</p>
<p>​        &gt;  计数信号量，K(k&gt;2)个线程互斥</p>
<p>​    •n&gt;1, 同步互斥(读写者问题)</p>
</li>
<li><p>The Producer/Consumer Problem</p>
<p><img src="https://s1.ax1x.com/2020/10/21/B9tSyT.png" alt="B9tSyT.png"></p>
<p>another example <strong>with Circular Buffer</strong>：</p>
<p><img src="https://s1.ax1x.com/2020/10/21/B9tpOU.png" alt="B9tpOU.png"></p>
<p><strong>producer:</strong></p>
<p><strong>while (true) {</strong></p>
<p> <strong>/* produce item v */</strong></p>
<p> <strong>while (**</strong>(in + 1) % n** <strong>== out)</strong>  </p>
<p>​        <strong>/* do nothing */;</strong></p>
<p> <strong>b[in] = v;</strong></p>
<p> <strong>in = (in + 1) % n</strong></p>
<p><strong>}</strong></p>
<p><strong>consumer:</strong></p>
<p><strong>while (true) {</strong></p>
<p> <strong>while (**</strong>in == out**<strong>)</strong></p>
<p> <strong>/* do nothing */;</strong></p>
<p> <strong>w = b[out];</strong></p>
<p> <strong>out = (out + 1) % n;</strong></p>
<p> <strong>/* consume item w */</strong></p>
<p><strong>}</strong></p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>Monitors（管程）</p>
<p><img src="https://s1.ax1x.com/2020/10/21/B9tPw4.png" alt="B9tPw4.png"></p>
<blockquote>
<p>定义：–Monitor is a software module consisting of one or more procedures, an initialization sequence, and local data(管程由一个或者多个过程、一段初始化代码和局部数据组成的软件模块).</p>
</blockquote>
<blockquote>
<p>the chief characteristics :</p>
<ol>
<li>–Local data variables are accessible only by the monitor 本地数据只能由监视器访问</li>
<li>–Process enters monitor by invoking one of its procedures 进程调用管程函数即进入管程</li>
<li>–Only one process may be executing in the monitor at a time</li>
</ol>
</blockquote>
<blockquote>
<p>管程的互斥机制：管程中的数据变量一次只能被一个进程访问</p>
<p>管程的同步机制：使用条件变量 cwait(c),csignal(c),如果管程中的一个进程发信号，但没有在这个条件变量上等待的任务，则丢弃这个信号。</p>
</blockquote>
<blockquote>
<p>管程优于信号量之处：所有的同步机制都被限制在管程内部，易于验证同步的正确性，还易于检测错误；若一个管程被正确的编写，所有进程对受保护资源的访问都是正确的，而对于信号量需要访问资源的所有进程都被正确的编写</p>
</blockquote>
</li>
<li><p>消息传递</p>
<ul>
<li><p>进程需要同步为了实施互斥，为了合作必须交换信息-&gt; 消息传递（<strong>可以在分布式系统，共享内存的单，多处理器系统中实现</strong>）</p>
</li>
<li><p>操作集：</p>
<p>​    <strong>send (destination, message)</strong></p>
<p>​    <strong>receive (source, message)</strong></p>
</li>
<li><p>同步：sender和receiver都可阻塞或者不阻塞，通常有三种组合</p>
<ol>
<li>–Blocking send, blocking receive 都被阻塞知道完成消息的传递</li>
<li>•Nonblocking send, blocking receive 发送者可以继续但接收者会被阻塞知道消息到达</li>
<li>•Nonblocking send, nonblocking receive 不要求任何一方等待</li>
</ol>
</li>
<li><p>寻址：确定目标进程和源进程</p>
<ol>
<li><p>•Direct addressing</p>
<p>–Send primitive includes a specific <strong>identifier</strong> of the destination process 发送原语包含目标进程的特定标识符</p>
<p>–Receive primitive could know ahead of time which process a message is expected or receive primitive could use source parameter to return a value when the receive operation has been performed 接收原语可以提前知道预期哪个处理消息，或者接收原语可以在执行接收操作时使用源参数返回值</p>
</li>
<li><p>•Indirect addressing</p>
<blockquote>
<p>消息不直接从发送者到接收者，发送到一个临时保存消息的队列（mailbox）组成的共享数据结构，一个进程给合适信箱发消息，另一个从信箱获取消息。</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/10/23/BA9xXt.png" alt="BA9xXt.png"></p>
<blockquote>
<p><em>进程和信箱关联可以是静态的或者动态的。端口常常静态关联到一个特定的进程上，也就是被永久地创建并指定。当有很多个发送者时也可以是动态关联的。</em></p>
</blockquote>
<blockquote>
<p>信箱的所有权：对于端口，由接受进程创建并一起销毁；对于通用的信箱，操作系统提供一个创建信箱的服务，由创建信箱的进程所有；由操作系统所有，销毁需要一个显示命令</p>
</blockquote>
</li>
</ol>
</li>
<li><p>消息格式</p>
<p><img src="https://s1.ax1x.com/2020/10/23/BACPAS.png" alt="BACPAS.png"></p>
</li>
<li><p>互斥使用消息传递</p>
<p><img src="https://s1.ax1x.com/2020/10/23/BAClh4.png" alt="BAClh4.png"></p>
<p><img src="https://s1.ax1x.com/2020/10/23/BACJj1.png" alt="BACJj1.png"></p>
</li>
<li><p>读写者问题</p>
<p>条件：任意读进程可以同时读取文件；一次只有一个写进程可以写；如果一个写进程正在写文件，禁止任何读进程读文件</p>
<p><img src="https://s1.ax1x.com/2020/10/23/BACgDP.png" alt="BACgDP.png"></p>
<ol>
<li><p>读者优先</p>
<p>–Once a single reader has begun to access the data area, it is possible for readers to retain control of the data area as long as there is at least one reader in the act of reading. Therefore, writers are subject to starvation.目前正在读，新的读会持续进入，写会饥饿</p>
<p><img src="https://s1.ax1x.com/2020/10/23/BAC2Hf.png" alt="BAC2Hf.png"></p>
<p><strong>优先体现在不需要在writemutex上排队等待</strong></p>
</li>
<li><p>写者优先</p>
<p>–no new readers are allowed access to the data area once at least one writer has declared a desire to write. 当有新的写存在，新的读不能进行读</p>
<p><img src="https://s1.ax1x.com/2020/10/23/BACcut.png" alt="BACcut.png"></p>
<p><strong>问题</strong>：1.当目前正在写：新的 读和写同时到达：读写都会在semWait(writemutex)上等待，因此需要竞争进入，不能保证写优先</p>
<p>2.当前正在读：新的读和写同时到达，写都会在semWait(writemutex)上等待，而读会直接执行readdata();</p>
<p>因此需要让写排队，故尝试新增readmutex来保证写优先。因此需要一旦有写，阻塞读.</p>
<p><img src="https://s1.ax1x.com/2020/10/23/BACyjI.png" alt="BACyjI.png"></p>
<p><strong>问题</strong>：Reader中的semsignal（readmutex）表示本次读已经开始，为下一次写优先释放信号</p>
<p>​            Reader的semsignal(readmutex)在前，而非函数尾，有利于下一个来的读尽快进入</p>
<p>假设目前正在写，那么同时来一个写和读，写会在semwait(writemutex)上等待，而读会在            semwait(readmutex)上等待，因此写会先进入</p>
<p>假设目前正在读，那么同时来一个写和读，第一个写和所有新的读都会在    semwait（readmutex）上等待，需要竞争；另外后续其它写会阻塞在mutex2无法进入临界区，这时无法让写越过后续在semwait（readmutex）上排队的所有的读。</p>
<p><strong>因为不在readmutex让后续读排长队，从而延迟后续的写，所以新增z，用于读排队</strong></p>
<p><img src="https://s1.ax1x.com/2020/10/23/BACsgA.png" alt="BACsgA.png"></p>
<p><strong>问题</strong>：解决了刚才提到的目前正在读情况下，新写和新读中新写无法优先的问题。因为读需要先在z上排队，而写在readmutex排队</p>
<p>在极端情况下，当前正在读，大量读源源不断的进入，那么就可能阻塞在semwait（readmutex）上，因为太多读，无法及时从该临界区退出。</p>
<p>这是突然来第一个写，写将阻塞在semwait(readmutex)上，那么就无法保证写优先，因此增加一个z，让读在z上排队，由于z的释放晚于readmutex，那么可以保证写优先。</p>
<p><strong>读阻塞在z，而z后于readmutex释放，利于写先进入</strong></p>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<h1 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h1><ol>
<li><p>死锁原理：</p>
<p>一组相互竞争系统资源或进行通信的进程间的永久阻塞，死锁是永久性的</p>
<ul>
<li>可重用资源：一次仅供一个进程安全且不因使用而耗尽的资源。</li>
<li>可消耗资源：可被创建和销毁的资源，例如中断，信号，消息</li>
<li>资源分配图：<img src="https://s1.ax1x.com/2020/11/04/BgUGJ1.png" alt="BgUGJ1.png"></li>
<li>死锁的条件：互斥，占有且等待，不可抢占，循环等待（前三个是必要条件，四个加起来才是充要条件）</li>
</ul>
</li>
<li><p>死锁预防：</p>
<ul>
<li><p>互斥：几乎不可能做到，因为操作系统必须支持互斥</p>
</li>
<li><p>占有且等待：要求进程一次性请求所有需要的资源，并阻塞这个进程知道所有请求都同时满足，但有3个缺点：<strong>可能被阻塞很长时间</strong>，<strong>分配给这个进程的全部资源不能被立即使用，也不能被其他需要的进程使用</strong>，<strong>一个进程无法预知它需要的资源</strong></p>
</li>
<li><p>不可抢占：–if a further request is denied , Process must release resource and request again（释放最初占有的资源）</p>
<p>Operating system may preempt a process to require it releases its resources(kill the process, higher prority)进程抢占进程</p>
</li>
<li><p>循环等待: 通过定义资源类型的线性顺序来预防</p>
</li>
</ul>
</li>
<li><p>死锁避免：允许三个必要条件，但确保不会到达死锁点</p>
<ul>
<li><p>进程启动拒绝：•Do not start a process if its demands might lead to deadlock(如果一个进程的请求会导致死锁，则不启动此进程，<strong>进程启动拒绝</strong>)</p>
<p><img src="https://s1.ax1x.com/2020/11/04/BgU0dH.png" alt="BgU0dH.png"></p>
<p>![image-20201028204922144](C:\Users\Jerry Yummy\AppData\Roaming\Typora\typora-user-images\image-20201028204922144.png)</p>
<p><img src="https://s1.ax1x.com/2020/11/04/BgUyWt.png" alt="BgUyWt.png"></p>
</li>
<li><p>资源分配拒绝：the <strong>banker’s algorithm</strong></p>
<p><img src="https://s1.ax1x.com/2020/11/04/BgUjw4.png" alt="BgUjw4.png"></p>
<p><img src="https://s1.ax1x.com/2020/11/04/Bgai6K.png" alt="Bgai6K.png"></p>
<p>确定一个资源分配序列不会导致死锁，进程结束分配给该进程的资源返回available向量中，再寻找下一个符合当前可分配资源的进程</p>
</li>
<li><p>Restrictions 限制of Deadlock Avoidance：</p>
<ol>
<li>必须事先声明每个进程请求的最大资源</li>
<li>所讨论的进程必须是无关的，即他们的执行顺序没有同步要求</li>
<li>分配的资源是固定的</li>
<li>在占有资源时，进程不能退出</li>
</ol>
</li>
</ul>
</li>
</ol>
<ol start="4">
<li><p>死锁检测：</p>
<ul>
<li>Recovery Strategies Once Deadlock Detected (死锁检测到后的解锁策略)</li>
</ul>
<p>–放弃所有死锁进程</p>
<p>–将每个死锁进程备份到以前定义的检查点，并重新启动所有进程 </p>
<ul>
<li>可能会出现原始死锁</li>
</ul>
<p>–连续中止死锁进程，直到死锁不再存在</p>
<p>–连续抢占资源，直到死锁不再存在</p>
<ul>
<li><p>被剥夺或者取消进程的选择标准：</p>
<p>到目前为止消耗的处理器时间最少；</p>
<p>到目前为止所产生的输出行数最少；</p>
<p>最多估计剩余时间；</p>
<p>迄今为止分配的资源最少；</p>
<p>最低优先级</p>
</li>
</ul>
</li>
<li><p>几种策略的优势和缺点：</p>
</li>
<li><p>一种综合死锁策略：</p>
<p>将资源分组到许多不同的资源类中；</p>
<p>使用前面定义的防止循环等待的线性排序策略来防止资源类之间的死锁；</p>
<p>Within a resource class, use the algorithm that is most appropriate for that class(每个类中使用适合于该类的策略)；</p>
<p>Mem: page/segment, 置换到辅存</p>
<p>内部资源： 排序</p>
</li>
<li><p>哲学家就餐问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">take_forks</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="comment">//获取左右两边的筷子</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Pil[%d], left[%d], right[%d]\n&quot;</span>, id, left(id), right(id));</span><br><span class="line">    pthread_mutex_lock(&amp;forks[left(id)]);</span><br><span class="line">    pthread_mutex_lock(&amp;forks[right(id)]);</span><br><span class="line">    <span class="comment">//printf(&quot;philosopher[%d]  take_forks...\n&quot;, id);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put_down_forks</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;philosopher[%d] is put_down_forks...\n&quot;</span>, id);</span><br><span class="line">    pthread_mutex_unlock(&amp;forks[left(id)]);</span><br><span class="line">    pthread_mutex_unlock(&amp;forks[right(id)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">philosopher_work</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id = *(<span class="keyword">int</span>*)arg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;philosopher init [%d] \n&quot;</span>, id);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        thinking(id);</span><br><span class="line">        take_forks(id);</span><br><span class="line">        eating(id);</span><br><span class="line">        put_down_forks(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该算法存在以下问题：当五个哲学家都想要进餐，分别拿起他们左边筷子的时候都恰好执行完</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//都恰好执行完</span></span><br><span class="line">pthread_mutex_unlock(&amp;forks[left(id)]);</span><br></pre></td></tr></table></figure>

<p>筷子已经被拿光了，等到他们再想拿右边的筷子的时候</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行</span></span><br><span class="line">pthread_mutex_unlock(&amp;forks[right(id)]);</span><br></pre></td></tr></table></figure>

<p>就全被阻塞了，这就出现了死锁。</p>
<p><strong>解决方案1</strong></p>
<p>利用信号量的保护机制实现。通过信号量mutex对eat（）之前的取左侧和右侧筷<br>子的操作进行保护，使之成为一个原子操作，这样可以防止死锁的出现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">philosopher_work</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id = *(<span class="keyword">int</span>*)arg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;philosopher init [%d] \n&quot;</span>, id);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        thinking(id);</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        take_forks(id);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        eating(id);</span><br><span class="line">        put_down_forks(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码有个问题就是同一时间只能有一个哲学家取筷子，效率比较低．但是可以防止死锁</p>
<p><strong>解决方案2</strong>:至多四个人拿起左边筷子，保证至少有一个人可以用餐，那么就能解决了，添加一个信号量room赋值等于4</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************</span></span><br><span class="line"><span class="comment"> *           every philosopher is in while loop: thinking -&gt; take_forks -&gt; eating -&gt; put_down_forks -&gt; thingking</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *           对于可能产生的死锁问题，我们这里采用一中解决的办法，那就是只有当哲学接的左右两只筷子均处于可用状态时，</span></span><br><span class="line"><span class="comment"> *           才允许他拿起筷子。这样就可以避免他们同时拿起筷子就餐，导致死锁。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *           如果2号哲学家在吃饭那么１号和３号就必须是在思考．</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> ************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5 <span class="comment">// five philosopher</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T_EAT 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> T_THINK 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N_ROOM  4  <span class="comment">//同一时间只允许４人用餐</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> left(phi_id) (phi_id+N-1)%N</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> right(phi_id) (phi_id+1)%N</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> &#123; think , hungry , eat  &#125;phi_state[N];</span><br><span class="line"><span class="keyword">sem_t</span> chopstick[N];</span><br><span class="line"><span class="keyword">sem_t</span> room;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thinking</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    sleep(T_THINK);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;philosopher[%d] is thinking...\n&quot;</span>, id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eating</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    sleep(T_EAT);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;philosopher[%d] is eating...\n&quot;</span>, id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">take_forks</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="comment">//获取左右两边的筷子</span></span><br><span class="line">    <span class="comment">//printf(&quot;Pil[%d], left[%d], right[%d]\n&quot;, id, left(id), right(id));</span></span><br><span class="line">    sem_wait(&amp;chopstick[left(id)]);</span><br><span class="line">    sem_wait(&amp;chopstick[right(id)]);</span><br><span class="line">    <span class="comment">//printf(&quot;philosopher[%d]  take_forks...\n&quot;, id);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put_down_forks</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;philosopher[%d] is put_down_forks...\n&quot;</span>, id);</span><br><span class="line">    sem_post(&amp;chopstick[left(id)]);</span><br><span class="line">    sem_post(&amp;chopstick[right(id)]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">philosopher_work</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> id = *(<span class="keyword">int</span>*)arg;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;philosopher init [%d] \n&quot;</span>, id);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        thinking(id);</span><br><span class="line">        sem_wait(&amp;room);</span><br><span class="line">        take_forks(id);</span><br><span class="line">        sem_post(&amp;room);</span><br><span class="line">        eating(id);</span><br><span class="line">        put_down_forks(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> phiTid[N];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">int</span> *id=(<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*N);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//initilize semaphore</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sem_init(&amp;chopstick[i], <span class="number">0</span>, <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;init forks error\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sem_init(&amp;room, <span class="number">0</span>, N_ROOM);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; N; ++i)&#123;</span><br><span class="line">        <span class="comment">//printf(&quot;i ==%d\n&quot;, i);</span></span><br><span class="line">        id[i] = i;</span><br><span class="line">        err = pthread_create(&amp;phiTid[i], <span class="literal">NULL</span>, philosopher_work, (<span class="keyword">void</span>*)(&amp;id[i])); <span class="comment">//这种情况生成的thread id是0,1,2,3,4</span></span><br><span class="line">        <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t create process for reader\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delete the source of semaphore</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        err = sem_destroy(&amp;chopstick[i]);</span><br><span class="line">        <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t destory semaphore\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决方案3</strong>：规定奇数号的哲学家先拿起他左边的筷子,然后再去拿他右边的筷子;而偶数号<br>的哲学家则相反.按此规定,将是1,2号哲学家竞争1号筷子,3,4号哲学家竞争3号筷子.即<br>五个哲学家都竞争奇数号筷子,获得后,再去竞争偶数号筷子,最后总会有一个哲学家能获<br>得两支筷子而进餐。而申请不到的哲学家进入阻塞等待队列，根FIFO原则，则先申请的哲<br>学家会较先可以吃饭，因此不会出现饿死的哲学家</p>
<p>修改函数如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">take_forks</span><span class="params">(``<span class="keyword">int</span>``id)</span></span>&#123;</span><br><span class="line">   ``<span class="comment">//获取左右两边的筷子``  ``</span></span><br><span class="line">	<span class="comment">//printf(&quot;Pil[%d], left[%d], right[%d]\n&quot;, id, left(id), right(id));</span></span><br><span class="line">	``  ``<span class="keyword">if</span>``((id&amp;<span class="number">1</span>) == <span class="number">1</span>)&#123;``    </span><br><span class="line">	``sem_wait(&amp;chopstick[left(id)]);``</span><br><span class="line">    ``sem_wait(&amp;chopstick[right(id)]);``  ``&#125;``  ``</span><br><span class="line">    <span class="keyword">else</span>  &#123;        sem_wait(&amp;chopstick[right(id)]);``    					 ``		               sem_wait(&amp;chopstick[left(id)]);</span><br><span class="line">           &#125;</span><br><span class="line">    <span class="comment">//printf(&quot;philosopher[%d] take_forks...\n&quot;, id);</span></span><br><span class="line">    ``&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://example.com/2020/11/04/operate%20system/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://example.com/2020/11/04/operate%20system/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a target="_blank" rel="noopener" href="http://miccall.tech " style="border-bottom: none;">jerry</a></li>
            </ul>
            
                <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>



 	
</html>
